import os
import platform
import subprocess
import json
import re
import tempfile
import time
from datetime import datetime
import requests

# Configurable environment name
CONDA_ENV_NAME = "myenv"
OLLAMA_URL = "http://localhost:11434/api/chat"
MODEL = "qwen2.5:7b" #"gemma3:12b-it-qat"
HISTORY_DIR = "history_logs"

os.makedirs(HISTORY_DIR, exist_ok=True)

def current_timestamp():
    return datetime.now().strftime("%Y-%m-%d_%H%M%S")

def check_conda_env(env_name):
    result = subprocess.run(["conda", "env", "list"], capture_output=True, text=True)
    if env_name not in result.stdout:
        raise EnvironmentError(f"‚ùå Conda environment '{env_name}' not found.")

def ask_model_for_code(prompt, history):
    messages = history + [{"role": "user", "content": prompt}]
    response = requests.post(
        OLLAMA_URL,
        headers={"Content-Type": "application/json"},
        json={
            "model": MODEL,
            "messages": messages,
            "stream": False,
            "options": {"temperature": 0.1}
        }
    )
    if response.status_code != 200:
        print(f"‚ùå Model request failed with status: {response.status_code}")
        return "", []

    reply = response.json().get("message", {}).get("content", "")
    print("\nü§ñ Python code generated by model:")
    print(reply)

    # Extract python code blocks
    blocks = re.findall(r"```python\s*([\s\S]*?)```", reply)
    codes = [block.strip() for block in blocks]
    return reply, codes

def execute_python(code):
    # Create a unique filename in the history directory
    timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
    random_suffix = os.urandom(3).hex()
    filename = f"script_{timestamp}_{random_suffix}.py"
    tmp_file_path = os.path.join(os.path.abspath(HISTORY_DIR), filename)
    
    with open(tmp_file_path, "w", encoding="utf-8") as f:
        f.write(code)
    print(f"üî® Temporary script path: {tmp_file_path}")

    try:
        cmd_list = ["conda", "run", "-n", CONDA_ENV_NAME, "python", tmp_file_path]
        print(f"‚ñ∂Ô∏è Running command: {' '.join(cmd_list)}")

        result = subprocess.run(
            cmd_list,
            capture_output=True,
            text=True,
            check=False
        )
        return result.stdout, result.stderr, tmp_file_path

    except Exception as e:
        print(f"‚ö†Ô∏è Error executing script: {e}")
        return "", str(e), tmp_file_path

def cleanup_temp_files(file_path, max_attempts=5, delay=1):
    """Attempt to remove temporary files with multiple retries"""
    for attempt in range(max_attempts):
        try:
            os.remove(file_path)
            print(f"üßπ Removed temporary script: {file_path}")
            return True
        except OSError as e:
            if attempt < max_attempts - 1:
                print(f"‚ö†Ô∏è Could not remove file on attempt {attempt+1}, retrying in {delay}s: {e}")
                time.sleep(delay)
            else:
                print(f"‚ö†Ô∏è Failed to remove temp script after {max_attempts} attempts: {e}")
                print(f"üí° Note: File will remain at {file_path}")
                return False

def main():
    os_name = platform.system()
    check_conda_env(CONDA_ENV_NAME)

    # Create a list to track temporary files for cleanup at the end
    temp_files = []

    print("ü§ñ Python Assistant Ready!")
    print(f"üí° Operating System: {os_name}")
    print(f"üí° Conda Env: {CONDA_ENV_NAME}")
    print("üîÅ Enter a task or press Enter to use default:")

    task = input("üìù Task description: ").strip()
    if not task:
        task = "Create an empty folder named 'test123' on the desktop"

    history = [{
        "role": "system",
        "content": (
            f"You are an assistant that converts natural language tasks into Python scripts. "
            f"The scripts will run in a Conda environment named {CONDA_ENV_NAME}. "
            "Wrap generated code in ```python ...```.\n"
            "After creating any file or directory, include a while loop that checks for its existence using os.path.exists() before proceeding."
        )
    }]

    session_log = {"start_time": current_timestamp(), "task": task, "codes": []}

    while True:
        full_reply, codes = ask_model_for_code(task, history)
        history.append({"role": "assistant", "content": full_reply})

        if not codes:
            print("‚ö†Ô∏è No code block detected, exiting.")
            break

        for idx, code in enumerate(codes, start=1):
            print(f"\nüí¨ Code block {idx}:\n{code}\nExecute? (y/n)")
            confirm = input("> ").strip().lower()
            if confirm in ("y", "yes"):
                stdout, stderr, temp_file = execute_python(code)
                temp_files.append(temp_file)  # Track the temp file
                
                print(f"üì§ Output of code {idx}:\n{stdout}")
                if stderr:
                    print(f"‚ö†Ô∏è Error in code {idx}:\n{stderr}")
                session_log["codes"].append({
                    "index": idx,
                    "code": code,
                    "executed": True,
                    "stdout": stdout,
                    "stderr": stderr,
                    "script_path": temp_file
                })
            else:
                print(f"üö´ Skipped code block {idx}")
                session_log["codes"].append({
                    "index": idx,
                    "code": code,
                    "executed": False,
                    "stdout": "",
                    "stderr": ""
                })

        print("\nüîÅ Any further tasks? Press Enter to exit or type new task:")
        task = input("üìù Next task: ").strip()
        if not task:
            break
        history.append({"role": "user", "content": task})
        session_log["task"] += " ‚Üí " + task

    # Save session log before cleanup attempts
    filename = os.path.join(HISTORY_DIR, f"{current_timestamp()}.json")
    with open(filename, "w", encoding="utf-8") as f:
        json.dump(session_log, f, indent=2, ensure_ascii=False)
    print(f"\n‚úÖ Task completed, session log saved: {filename}")
    
    # Try to clean up temporary files at the end
    print("\nüßπ Cleaning up temporary files...")
    for temp_file in temp_files:
        cleanup_temp_files(temp_file)
    
    print("üëã Session complete!")

if __name__ == "__main__":
    main()
